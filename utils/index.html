<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <title>Ambisafe Ethereum Utils</title>
</head>
<body>
    <h1>Ambisafe Ethereum Utils</h1>
    <h4>To begin, do: setPrivateKey('yourPkHere'); in the browser javascript console.</h4>
    <h3>Example usage, test func will return false if there is less than 500000 gas available inside it:</h3>
    <p>var ambiUtils = web3.eth.contract([{"constant":false,"inputs":[],"name":"kill","outputs":[],"type":"function"},{"constant":false,"inputs":[],"name":"test","outputs":[{"name":"","type":"bool"}],"type":"function"}]).at("0x75c5751b5eca193c5e38e1128f543b0250e24b0a");</p>
    <p>safeTransaction(ambiUtils.test, [], address, {testRun: true});</p>
    <p>safeTransaction(ambiUtils.test, [], address, {testRun: true, ignoreCallResponse: true});</p>
    <p>safeTransaction(ambiUtils.test, [], address, {testRun: true, gas: 1000000});</p>
    <p>safeTransaction(ambiUtils.test, [], address, {waitReceipt: true}); // Will fail on checks.</p>
    <p>safeTransaction(ambiUtils.test, [], address, {waitReceipt: true, gas: 1000000}); // Submitting real transaction!</p>
    <p>var tx1 = safeTransactionFunction(ambiUtils.test, [], address, {gas: 1000000});</p>
    <p>var tx2 = safeTransactionFunction(ambiUtils.test, [], address); // Will stop on this one.</p>
    <p>var tx3 = safeTransactionFunction(ambiUtils.test, [], address, {ignoreCallResponse: true});</p>
    <p>safeTransactions([tx1, tx2, tx3], true); // true means testRun for all transactions;</p>
    <h3>Logs</h3>
    <div id='logs'>
    </div>
    <script>
        window.opts = {
            gethUrl: 'http://52.28.142.166:8545',
            pk: ''
        }
    </script>
    <script src='../build/bundle.js'></script>
    <script src='//code.jquery.com/jquery-2.2.2.min.js'></script>
    <script>
        var $logs = $('#logs');
        var web3 = EToken.web3;
        var eth = web3.eth;
        var address;

        var cb = function(err,ok){if (err) {console.log(err);} else {console.log(ok);}};
        var cbval = function(err,ok){if (err) {console.log(err);} else {console.log(ok.valueOf());}};

        var setPrivateKey = function(pk) {
            EToken.setPrivateKey(pk);
            address = EToken.privateToAddress(pk[1] == 'x' ? pk : '0x' + pk);
            log('Your address(global variable) to send transactions: ' + address, $logs);
        };

        var _log = function(message, logger) {
          logger.prepend(message);
        }

        var log = function(message, logger) {
            console.log(message);
            if (logger) {
                _log('<p>' + message + '</p>', logger);
            }
        };

        var logError = function(message, logger) {
            if (logger) {
                _log('<p class="error">' + message + '</p>', logger);
            }
            throw message;
        };

        var logSuccess = function(gas, result, params, logger) {
            if (logger) {
                var txHash = result.length === 66 ? '<a href="http://etherscan.io/tx/' + result + '">' + result + '</a>' : result;
                _log('<p class="success">Success! Gas used: ' + gas + ' result: ' + txHash + (params ? ' params: ' + params.toString() : '') + '</p>', logger);
            }
            console.log('Success! Gas used: ' + gas + ' result: ' + result + (params ? ' params: ' + params.toString() : ''));
        };

        var safeTransaction = function(fun, params, sender, argsObject) {
          safeTransactionFunction(fun, params, sender, argsObject)();
        };

        var safeTransactionFunction = function(fun, params, sender, argsObject) {
          var merge = function(base, args) {
            var target = ['nonce', 'value', 'gasPrice', 'to', 'data'];
            if (args) {
              while(target.length > 0) {
                var arg = target.pop();
                if (args[arg]) {
                  base[arg] = args[arg];
                }
              }
            }
            return base;
          };

          var processFunctionParams = function(paramsToProcess) {
            for (var i = 0; i < paramsToProcess.length; i++) {
              if (typeof paramsToProcess[i] === 'function') {
                paramsToProcess[i] = paramsToProcess[i]();
              }
            }
          };

          var gas = (argsObject && argsObject.gas) ? argsObject.gas : 500000;
          return function(testRun) {
            processFunctionParams(params);
            return new Promise(function(resolve, reject) {
              var _params = params.slice(0);
              _params.push(merge({from: sender, gas: 3000000}, argsObject));
              _params.push(function(err, result) {
                if (err) {
                  reject(err);
                } else {
                  resolve(result);
                }
              });
              fun.estimateGas.apply(this, _params);
            }).then(function(estimateGas) {
              return new Promise(function(resolve, reject) {
                var _params = params.slice(0);
                if (estimateGas > gas) {
                  reject('Estimate gas is too big: ' + estimateGas);
                } else {
                  _params.push(merge({from: sender, gas: gas}, argsObject));
                  _params.push(function(err, result) {
                    result = typeof result === 'number' ? result > 0 : result;
                    if (err) {
                      reject(err);
                    } else {
                      if (result || (argsObject && argsObject.ignoreCallResponse)) {
                        resolve(estimateGas);
                      } else {
                        reject('Call with gas: ' + gas + ' returned false.');
                      }
                    }
                  });
                  fun.call.apply(this, _params);
                }
              });
            }).then(function(estimateGas) {
              return new Promise(function(resolve, reject) {
                var _params = params.slice(0);
                _params.push(merge({from: sender, gas: gas}, argsObject));
                _params.push(function(err, result) {
                  if (err) {
                    reject(err);
                  } else {
                    resolve([result, estimateGas]);
                  }
                });
                if (testRun || (argsObject && argsObject.testRun)) {
                  resolve(['OK', estimateGas]);
                  return;
                }
                fun.apply(this, _params);
              });
            }).then(function(result) {
              logSuccess(result[1], result[0], params.toString(), $logs);
              if (!testRun && argsObject && !argsObject.testRun && argsObject.waitReceipt) {
                log('Waiting receipt for ' + result[0], $logs);
                return new Promise(function(resolve, reject) {
                  var waitReceipt = function(txHash, tryNum) {
                    web3.eth.getTransactionReceipt(txHash, function(err, receipt) {
                      if (receipt) {
                        resolve([tryNum, result[1]]);
                      } else {
                        if (tryNum > 120) {
                          reject('No transaction receipt after >120 seconds.');
                        } else {
                          setTimeout(waitReceipt(txHash, tryNum + 1), 1000);
                        }
                      }
                    });
                  };
                  waitReceipt(result[0], 1);
                });
              } else {
                return [false, result[1]];
              }
            }).then(function(results) {
              if (results[0]) {
                log('Mined in ' + results[0] + ' seconds.', $logs);
              }
              return results[1];
            }).catch(function(err) {
              logError(err, $logs);
            });
          };
        };

        var safeTransactions = function(txFunctions, testRun, cumulativeGasUsed) {
          cumulativeGasUsed = cumulativeGasUsed || 0;
          if (txFunctions.length === 0) {
            log('Done! Cumulative gas used: ' + cumulativeGasUsed, $logs);
            return true;
          }
          txFunctions.shift()(testRun).then(function(gasUsed){
            safeTransactions(txFunctions, testRun, cumulativeGasUsed + (gasUsed || 0));
          });
        };

        var call = function(contract, properties, target) {
          callFunction(contract, properties, target)();
        }

        var callFunction = function(contract, properties, target) {
          var processResult = function(property, alias, done, reject) {
            return function(error, result) {
              if (error) {
                reject("Error while calling property '" + property + "' with message: " + error);
              } else {
                target[alias] = result;
                done();
              }
            };
          };

          return function() {
            return new Promise(function(resolve, reject) {
              var propertiesCount = properties.length;
              var finished = function() {
                if (--propertiesCount === 0) {
                  log("Properties collected!", $logs);
                  resolve();
                }
              };
              if (propertiesCount === 0) {
                reject("Properties array cannot be empty.");
                return;
              }
              properties.forEach(function(property) {
                if (typeof property === 'object') {
                  var params = property.params || [];
                  var alias = property.alias || property.name;
                  params.push(processResult(property.name, alias, finished, reject));
                  contract[property.name].call.apply(this, params)
                } else {
                  contract[property].call(processResult(property, property, finished, reject));
                }
                log("Calling for property: " + (property.name || property), $logs);
              });
            });
          };
        };

        var asyncFunction = function(fun) {
          return function() {
            return new Promise(function(resolve, reject) {
              fun(resolve, reject);
            });
          };
        };

        var syncFunction = function(fun) {
          return function() {
            return new Promise(function(resolve, _) {
              fun();
              resolve();
            });
          };
        };
    </script>
    <style>
        p {
            margin: 2px;
        }
        p.success {
            color: green;
        }
        p.error {
            color: red;
        }
        a:visited {
            color: darkgreen;
        }
        a:link {
            color: darkseagreen;
        }
    </style>
</body>
</html>