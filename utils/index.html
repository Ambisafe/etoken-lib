<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <title>Ambisafe Ethereum Utils</title>
</head>
<body>
    <h1>Ambisafe Ethereum Utils</h1>
    <h4>To begin, do: setPrivateKey('yourPkHere'); in the browser javascript console.</h4>
    <h3>Example usage, test func will return false if there is less than 500000 gas available inside it:</h3>
    <p>var ambiUtils = web3.eth.contract([{"constant":false,"inputs":[],"name":"kill","outputs":[],"type":"function"},{"constant":false,"inputs":[],"name":"test","outputs":[{"name":"","type":"bool"}],"type":"function"}]).at("0x75c5751b5eca193c5e38e1128f543b0250e24b0a");</p>
    <p>safeTransaction(ambiUtils.test, [], address, {testRun: true});</p>
    <p>safeTransaction(ambiUtils.test, [], address, {testRun: true, ignoreCallResponse: true});</p>
    <p>safeTransaction(ambiUtils.test, [], address, {testRun: true, gas: 1000000});</p>
    <p>safeTransaction(ambiUtils.test, [], address, {waitReceipt: true}); // Will fail on checks.</p>
    <p>safeTransaction(ambiUtils.test, [], address, {waitReceipt: true, gas: 1000000}); // Submitting real transaction!</p>
    <p>var tx1 = safeTransactionFunction(ambiUtils.test, [], address, {gas: 1000000});</p>
    <p>var tx2 = safeTransactionFunction(ambiUtils.test, [], address); // Will stop on this one.</p>
    <p>var tx3 = safeTransactionFunction(ambiUtils.test, [], address, {ignoreCallResponse: true});</p>
    <p>safeTransactions([tx1, tx2, tx3], true); // true means testRun for all transactions;</p>
    <p>safeSend(ambiUtils.address, 1000, address, {testRun: true}); // Send 100 wei.</p>
    <p>safeSendAll(ambiUtils.address, address, {testRun: true}); // Send all you have available, will result in 0 wei on sender.</p>
    <p>safeTopup(ambiUtils.address, 1488, address, {testRun: true}); // Send enough for the receiver to have exactly 1488 wei.</p>
    <pre>fastTopups([ // Will topup to the specified balance.
  fastTopupFunction('0x1c4a10b09f54c2a2601b71e7644124efefd2cd7b', 20000000000000001, address),
  fastTopupFunction('0x4793f63e6e270a78c9533ba2743905beeade40a6', 20000000000000100, address),
  fastTopupFunction('0x787f0a7639fd444ae6464e02f29763f06c76232f', 10000000000000000, address),
  fastTopupFunction('0x8622c07a3b6496df703ab644698162c3f265a98b', 20000200020000000, address)
], 0, true); // 0 is the first unused nonce. Testrun true.</pre>

    <h3>Logs</h3>
    <div id='logs'>
    </div>
    <script>
        window.opts = {
            gethUrl: 'http://52.28.142.166:8545',
            pk: ''
        }
    </script>
    <script src='../build/bundle.js'></script>
    <script src='//code.jquery.com/jquery-2.2.2.min.js'></script>
    <script>
        var $logs = $('#logs');
        var web3 = EToken.web3;
        var eth = web3.eth;
        var address;

        var nowSeconds = function(){return (Date.now() / 1000);};

        var gasPrice = web3.toBigNumber(web3.toWei(20, 'gwei'));

        var cb = function(err,ok){if (err) {console.log(err);} else {console.log(ok);}};
        var cbval = function(err,ok){if (err) {console.log(err);} else {console.log(ok.valueOf());}};

        var setPrivateKey = function(pk) {
            EToken.setPrivateKey(pk);
            address = EToken.privateToAddress(pk[1] == 'x' ? pk : '0x' + pk);
            log('Your address(global variable) to send transactions: ' + address, $logs);
        };

        var _log = function(message, logger) {
          logger.prepend(message);
        }

        var log = function(message, logger) {
            console.log(message);
            if (logger) {
                _log('<p>' + message + '</p>', logger);
            }
        };

        var logError = function(message, logger) {
            if (logger) {
                _log('<p class="error">' + message + '</p>', logger);
            }
            throw message;
        };

        var logWarning = function(message, logger) {
            if (logger) {
                _log('<p class="warning">' + message + '</p>', logger);
            }
            console.log('Warning: ' + message);
        };

        var logSuccess = function(gas, result, params, logger) {
            if (logger) {
                var txHash = result.length === 66 ? '<a href="http://etherscan.io/tx/' + result + '">' + result + '</a>' : result;
                _log('<p class="success">Success! Gas used: ' + gas + ' result: ' + txHash + (params ? ' params: ' + params : '') + '</p>', logger);
            }
            console.log('Success! Gas used: ' + gas + ' result: ' + result + (params ? ' params: ' + params : ''));
        };

        var logWaiting = function(logger) {
          if (logger) {
            $(logger.children()[0]).append('.');
          }
        };

        var logFinish = function(logger) {
          if (logger) {
            _log('<hr/>', logger);
          }
          console.log('--------------------------------------------------------------------------------');
        }

        var flowControl = function() {
          var STATES = { ready: 'ready', waiting: 'waiting', stopping: 'stopping' };
          var state = STATES.ready;
          return {
            get ready () {
              return state === STATES.ready;
            },
            get waiting () {
              return state === STATES.waiting;
            },
            get stopping () {
              return state === STATES.stopping;
            },
            get state () {
              return state;
            },
            stop: function() {
              if (state === STATES.waiting) {
                state = STATES.stopping;
              }
              return state;
            },
            continue: function() {
              if (state === STATES.waiting || state === STATES.stopping) {
                state = STATES.ready;
              }
              return state;
            },
            __wait__: function() {
              state = STATES.waiting;
              return state;
            }
          };
        }();

        var safeTransaction = function(fun, params, sender, argsObject) {
          safeTransactionFunction(fun, params, sender, argsObject)().then(function() {
            logFinish($logs);
          });
        };

        var safeSend = function(to, value, sender, argsObject) {
          safeSendFunction(to, value, sender, argsObject)().then(function() {
            logFinish($logs);
          });
        };

        var safeSendAll = function(to, sender, argsObject) {
          eth.getBalance(sender, 'pending', function(err, balance) {
            if (err) {
              throw err;
            }
            var gas = argsObject && argsObject.gas || 21000;
            var value = balance.sub(gasPrice.mul(gas));
            safeSend(to, value, sender, argsObject);
          });
        };

        var safeTopup = function(to, targetValue, sender, argsObject) {
          safeTopupFunction(to, targetValue, sender, argsObject)().then(function() {
            log('Topup to ' + to + ' finished.', $logs);
            logFinish($logs);
          });
        };

        var safeTopupFunction = function(to, targetValue, sender, argsObject) {
          return asyncFunction(function(resolve, reject, testRun) {
            eth.getBalance(to, 'pending', function(err, balance) {
              if (err) {
                reject(err);
                return;
              }
              var value = web3.toBigNumber(targetValue).sub(balance);
              if (value.lte(0)) {
                log("Skipping: balance of " + to + " is " + web3.fromWei(balance, 'ether') + " ETH and it is more or equal to target value of " + web3.fromWei(targetValue, 'ether') + " ETH.", $logs);
                resolve(0);
                return;
              }
              safeSendFunction(to, value, sender, argsObject)(testRun).then(resolve).catch(reject);
            });
          });
        };

        var fastTopup = function(to, targetValue, sender, nonce, argsObject) {
          fastTopupFunction(to, targetValue, sender, argsObject)(nonce).then(function(nonce) {
            log('Topup to ' + to + ' finished. Next nonce: ' + nonce, $logs);
          });
        };

        var fastTopupFunction = function(to, targetValue, sender, argsObject) {
          return function(nonce, _testRun) {
            return asyncFunction(function(resolve, reject, testRun) {
              eth.getBalance(to, 'pending', function(err, balance) {
                if (err) {
                  reject(err);
                  return;
                }
                var value = web3.toBigNumber(targetValue).sub(balance);
                if (value.lte(0)) {
                  log("Skipping: balance of " + to + " is " + web3.fromWei(balance, 'ether') + " ETH and it is more or equal to target value of " + web3.fromWei(targetValue, 'ether') + " ETH.", $logs);
                  resolve(nonce);
                  return;
                }
                resolve(nonce+1);
                if (argsObject) {
                  argsObject.nonce = nonce;
                } else {
                  argsObject = {nonce: nonce};
                }
                safeSendFunction(to, value, sender, argsObject)(testRun).catch(function(error) {
                  throw error;
                });
              });
            })(_testRun);
          };
        };

        var fastTopups = function(txFunctions, nonce, testRun) {
          if (txFunctions.length === 0) {
            setTimeout(function() {
              log('Done! Next nonce: ' + nonce + '.', $logs);
              logFinish($logs);
            }, 2000);
            return true;
          }
          txFunctions.shift()(nonce, testRun).then(function(nextNonce){
            fastTopups(txFunctions, nextNonce, testRun);
          });
        };

        var safeSendFunction = function(to, value, sender, argsObject) {
          argsObject = argsObject || {};
          argsObject.value = argsObject.value || value;
          argsObject.to = argsObject.to || to;
          return safeTransactionFunction(eth.sendTransaction, [], sender, argsObject);
        };

        var safeTransactionFunction = function(fun, params, sender, argsObject) {
          var merge = function(base, args) {
            var target = ['nonce', 'value', 'gasPrice', 'to', 'data'];
            if (args) {
              while(target.length > 0) {
                var arg = target.pop();
                if (args[arg]) {
                  base[arg] = args[arg];
                }
              }
            }
            return base;
          };

          var processFunctionParams = function(paramsToProcess) {
            for (var i = 0; i < paramsToProcess.length; i++) {
              if (typeof paramsToProcess[i] === 'function') {
                paramsToProcess[i] = paramsToProcess[i]();
              }
            }
          };

          var waitReceiptTimeoutSeconds = 120;
          var gas = argsObject && argsObject.gas || 500000;
          return function(testRun) {
            processFunctionParams(params);
            return new Promise(function(resolve, reject) {
              var _params = params.slice(0);
              _params.push(merge({from: sender, gas: 3000000}, argsObject));
              _params.push(function(err, result) {
                if (err) {
                  if (err.toString().startsWith('Error: no contract code at given address')) {
                    gas = argsObject && argsObject.gas || 21000;
                    resolve(gas);
                    return;
                  }
                  reject(err);
                } else {
                  resolve(result);
                }
              });
              if (typeof fun.call === "string") {
                eth.estimateGas.apply(this, _params);
              } else {
                fun.estimateGas.apply(this, _params);
              }
            }).then(function(estimateGas) {
              return new Promise(function(resolve, reject) {
                var _params = params.slice(0);
                if (estimateGas > gas) {
                  reject('Estimate gas is too big: ' + estimateGas);
                } else if (typeof fun.call === "string") {
                  // simple eth.sendTransaction
                  resolve(estimateGas);
                } else {
                  _params.push(merge({from: sender, gas: gas}, argsObject));
                  _params.push(function(err, result) {
                    result = typeof result === 'number' ? result > 0 : result;
                    if (err) {
                      reject(err);
                    } else {
                      if (result || (argsObject && argsObject.ignoreCallResponse)) {
                        resolve(estimateGas);
                      } else {
                        reject('Call with gas: ' + gas + ' returned false.');
                      }
                    }
                  });
                  fun.call.apply(this, _params);
                }
              });
            }).then(function(estimateGas) {
              return new Promise(function(resolve, reject) {
                var _params = params.slice(0);
                _params.push(merge({from: sender, gas: gas}, argsObject));
                _params.push(function(err, result) {
                  if (err) {
                    reject(err);
                  } else {
                    resolve([result, estimateGas]);
                  }
                });
                if (testRun || (argsObject && argsObject.testRun)) {
                  resolve(['OK', estimateGas]);
                  return;
                }
                fun.apply(this, _params);
              });
            }).then(function(result) {
              var value = (argsObject && argsObject.value) ? " value: " + web3.fromWei(argsObject.value.valueOf(), 'ether') + " ETH." : "";
              var to = (argsObject && argsObject.to) ? " to: " + argsObject.to : "";
              var nonce = (argsObject && argsObject.nonce !== undefined) ? " nonce: " + argsObject.nonce : "";
              logSuccess(result[1], result[0], params.join(', ') + to + value + nonce, $logs);
              if (!testRun && argsObject && !argsObject.testRun && argsObject.waitReceipt) {
                log('Waiting receipt for ' + result[0], $logs);
                return new Promise(function(resolve, reject) {
                  flowControl.__wait__();
                  var startTime = nowSeconds();
                  var timeoutTime = startTime + waitReceiptTimeoutSeconds;
                  var waitReceipt = function(txHash) {
                    web3.eth.getTransactionReceipt(txHash, function(err, receipt) {
                      var secondsPassed = Math.round(nowSeconds() - startTime);
                      if (receipt || flowControl.ready) {
                        flowControl.continue();
                        resolve([secondsPassed, result[1]]);
                      } else {
                        var message = 'No transaction receipt after ' + secondsPassed + ' seconds.';
                        if (flowControl.stopping) {
                          flowControl.continue();
                          reject(message);
                          return;
                        }
                        if (nowSeconds() > timeoutTime) {
                          logWarning(message + " If you are sure that transaction is already mined do: flowControl.continue(); If you want to stop execution do: flowControl.stop();", $logs);
                          timeoutTime += 60;
                        }
                        logWaiting($logs);
                        setTimeout(waitReceipt(txHash), 1000);
                      }
                    });
                  };
                  waitReceipt(result[0]);
                });
              } else {
                return [false, result[1]];
              }
            }).then(function(results) {
              if (results[0]) {
                log('Mined in ' + results[0] + ' seconds.', $logs);
              }
              return [results[1], argsObject && argsObject.value];
            }).catch(function(err) {
              logError(err, $logs);
              log('<hr/>', $logs);
            });
          };
        };

        var safeTransactions = function(txFunctions, testRun, cumulativeGasUsed, totalValueSpent) {
          cumulativeGasUsed = cumulativeGasUsed || 0;
          totalValueSpent = totalValueSpent || 0;
          if (txFunctions.length === 0) {
            log('Done! Cumulative gas used: ' + cumulativeGasUsed + ', total value sent: ' + web3.fromWei(totalValueSpent, 'ether') + ' ETH.', $logs);
            logFinish($logs);
            return true;
          }
          txFunctions.shift()(testRun).then(function(gasUsedAndvalueSpent){
            var gasUsed = gasUsedAndvalueSpent && gasUsedAndvalueSpent[0] || 0;
            var valueSent = web3.toBigNumber(gasUsedAndvalueSpent && gasUsedAndvalueSpent[1] || 0);
            safeTransactions(txFunctions, testRun, cumulativeGasUsed + gasUsed, valueSent.add(totalValueSpent));
          });
        };

        var call = function(contract, properties, target) {
          callFunction(contract, properties, target)().then(function() {
            logFinish($logs);
          });
        }

        var callFunction = function(contract, properties, target) {
          var processResult = function(property, alias, done, reject) {
            return function(error, result) {
              if (error) {
                reject("Error while calling property '" + property + "' with message: " + error);
              } else {
                target[alias] = result;
                done();
              }
            };
          };

          return function() {
            return new Promise(function(resolve, reject) {
              var propertiesCount = properties.length;
              var finished = function() {
                if (--propertiesCount === 0) {
                  log("Properties collected!", $logs);
                  resolve();
                }
              };
              if (propertiesCount === 0) {
                reject("Properties array cannot be empty.");
                return;
              }
              properties.forEach(function(property) {
                if (typeof property === 'object') {
                  var params = property.params || [];
                  var alias = property.alias || property.name;
                  var name = property.name;
                } else {
                  var params = [];
                  var alias = property;
                  var name = property;
                }
                params.push(processResult(name, alias, finished, reject));
                if (contract.call === 'eth_getBalance') {
                  contract.apply(this, params);
                } else {
                  contract[name].call.apply(this, params);
                }
                log("Calling for property: " + name, $logs);
              });
            });
          };
        };

        var asyncFunction = function(fun) {
          return function(testRun) {
            return new Promise(function(resolve, reject) {
              fun(resolve, reject, testRun);
            });
          };
        };

        var syncFunction = function(fun) {
          return function(testRun) {
            return new Promise(function(resolve, _) {
              fun(testRun);
              resolve();
            });
          };
        };
    </script>
    <style>
        body {
          font-family: monospace;
        }
        p {
            margin: 2px;
        }
        p.success {
            color: green;
        }
        p.error {
            color: red;
        }
        p.warning {
            color: orangered;
        }
        a:visited {
            color: darkgreen;
        }
        a:link {
            color: darkseagreen;
        }
    </style>
</body>
</html>